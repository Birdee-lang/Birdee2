import fmt
import list:list
#import hash_set:hash_set
#import hash_map:hash_map
#import stack:stack
#import queue:queue

declare function getchar() as int

@enable_rtti
class assertion_exception

end

{@
from bdutils import *
def line_pos():
	strpos = str(get_cur_script().pos)
	set_ast(StringLiteralAST.new(strpos))
@}

function assert(v as boolean, msg as string)
	if !v then
		println("Assertion failed :" + msg)
		throw new assertion_exception
	end
end

function check_list[T](lst as list[T], chk as T[], pos as string)
	dim itr = lst.front()
	println("Checking " + pos)
	assert(lst.size() == chk.length(), {@line_pos()@})
	for dim i=0 till chk.length()
		assert(itr!=lst.ends(), {@line_pos()@})
		assert(itr.get() == chk[i], {@line_pos()@})
		itr.forward()
	end
	assert(itr == lst.ends(), {@line_pos()@})
end

# test list
dim lst = new list[int]

assert(lst.size()==0 , {@line_pos()@})
assert(lst.empty(), {@line_pos()@})

lst.insert_back(123)
lst.insert_back(234)
lst.insert_back(345)

check_list(lst,[123,234,345], {@line_pos()@})
assert(!lst.empty(), {@line_pos()@})

lst.remove(lst.front())
check_list(lst,[234,345], {@line_pos()@})

lst.remove(lst.back())
check_list(lst,[234], {@line_pos()@})

lst.insert_front(2)
check_list(lst,[2,234],{@line_pos()@})

dim itr = lst.front().next()
lst.insert_after(itr, 32)
check_list(lst,[2,234,32],{@line_pos()@})

lst.insert_before(itr, 44)
check_list(lst,[2,44,234,32],{@line_pos()@})

assert(lst.back() == itr.next(), {@line_pos()@})
lst.remove(lst.back())
assert(lst.back() == itr, {@line_pos()@})
assert(lst.ends() == itr.next(), {@line_pos()@})
lst.remove(lst.back())

println("Done")
getchar()

##
# test queue
dim q = new queue[uint]

println(int2str(q.get_size()))
q.push(10)
println(int2str(q.get_size()))
q.push(20)
println(int2str(q.get_size()))
q.push(30)
println(int2str(q.get_size()))
q.push(40)
println(int2str(q.get_size()))
q.push(50)
println(int2str(q.get_size()))

println(int2str(q.front()))
q.pop()
println(int2str(q.front()))
q.pop()
println(int2str(q.front()))
q.pop()
println(int2str(q.front()))
q.pop()
println(int2str(q.front()))
q.pop()

println(int2str(q.get_size()))

getchar()

# test stack
dim s = new stack[uint]

println(int2str(s.get_size()))
s.push(10)
println(int2str(s.get_size()))
s.push(20)
println(int2str(s.get_size()))
s.push(30)
println(int2str(s.get_size()))
s.push(40)
println(int2str(s.get_size()))
s.push(50)
println(int2str(s.get_size()))

println(int2str(s.top()))
s.pop()
println(int2str(s.top()))
s.pop()
println(int2str(s.top()))
s.pop()
println(int2str(s.top()))
s.pop()
println(int2str(s.top()))
s.pop()

println(int2str(s.get_size()))

getchar()

# test hash_set
dim hs = new hash_set[string]

println(int2str(hs.get_size()))
hs.insert("1")
hs.insert("999")
hs.insert("999")
hs.insert("999")
hs.insert("7567")
hs.insert("7567")
hs.insert("7567")

println(int2str(hs.get_size()))

hs.insert("7")
hs.insert("8")
hs.insert("9")

println(int2str(hs.get_size()))

hs.insert("10")
hs.insert("11")
hs.insert("12")
hs.insert("13")
hs.insert("14")

println(int2str(hs.get_size()))

if hs.has("1") then
	println("hs has 1: good")
end

if hs.has("2") then
	println("hs has 2: bad")
end

if hs.has("999") then
	println("hs has 999: good")
end

hs.remove("999")

if hs.has("999") then
	println("hs has 999: bad")
end

hs.clear()

if hs.has("2") then
	println("hs has 2: bad")
end
if hs.has("7567") then
	println("hs has 7567: bad")
end
println(int2str(hs.get_size()))

getchar()
##
