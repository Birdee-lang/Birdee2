package system.io


import concurrent.syncdef:*
import system.specific.win32.net:*
import system.io.netdef:*
import typedptr:sizeof
import functional.option:*

{@from system_0specific_0win32_0net import *@}



class socket_t
	public sock as SOCKET
	public function __init__(sock as SOCKET)
		this.sock = sock
	end
	
	public function send(buf as byte[], offset as uint, len as uint) as uint
		dim retlen = _send(sock, addressof(buf[offset]), len, 0)
		if retlen != len then
			dim err = get_socket_error()
			if err != 0 then
				throw mksocket_exception("Send error")
			end
		end
		return retlen
	end

	public function recv(buf as byte[], offset as uint, len as uint) as uint
		dim retlen = _recv(sock, addressof(buf[offset]), len, 0)
		if retlen != len then
			dim err = get_socket_error()
			if err != 0 then
				throw mksocket_exception("Send error")
			end
		end
		return retlen
	end

	public function recv_async(buf as byte[], offset as uint, len as uint) as future[int]
		return _recv_async(sock, buf, offset, len)
	end

	public function send_async(buf as byte[], offset as uint, len as uint) as future[int]
		return _send_async(sock, buf, offset, len)
	end

	public function close() => sock.close()
	public function __del__() => sock.close()
end


class server_bind
	public sock as SOCKET
	private async_sock as socket_future
	public function __init__(port as int)
		async_sock = null
		sock = _socket({@AF_INET()@}, {@SOCK_STREAM()@}, {@IPPROTO_TCP()@})
		if !sock.ok() then
			throw mksocket_exception("Socket error")
		end
		
	    dim sin = mk_sockaddr_in()
		sin.sin_family = mk_ushort({@AF_INET()@})
		dim short_port = mk_ushort(port)
		sin.sin_port.lo = short_port.hi
		sin.sin_port.hi = short_port.lo
		sin.sin_addr = {@INADDR_ANY()@} 
		if _bind(sock, addressof(sin), sizeof[sockaddr_in]()) == {@SOCKET_ERROR()@} then
			dim err = get_socket_error()
			sock.close()
			throw new socket_exception("Bind error", err)
		end
		if _listen(sock, 5) == {@SOCKET_ERROR()@} then
			dim err = get_socket_error()
			sock.close()
			throw new socket_exception("Listen error", err)
		end
	end

	public function accept() as socket_t
		dim ret = _accept(sock, pointerof(null), pointerof(null))
		if !ret.ok() then
			throw mksocket_exception("Accept error")
		end
		return new socket_t(ret)
	end

	public function accept_async() as future[socket_t]
		return _accept_async(sock, typedptr.mkref[socket_future](addressof(async_sock))).and_then(func (s as option[SOCKET]) as option[socket_t]
			if s.is_defined() then
				return some(new socket_t(s.get()))
			else
				return none[socket_t]()
			end
		end)
	end

	public function close()
		sock.close()
		async_sock.__del__()
	end
	public function __del__() => sock.close()
end



dim server = new server_bind(10086)
dim poll = new system.specific.win32.concurrent.poller

dim accept_conn = poll.add(null)

class connection_handler

	private s as socket_t
	private buf as byte[]
	private conn as awaitable_wrapper

	public function recv_callback(sz as option[int]) as option[int]
		println("RECV")
		dim len = sz.get()
		if len != 0 then
			s.send_async(buf, 0, len).await().get()
			poll.replace(conn, this.recv())
		else
			s.close()
			poll.remove(conn)
			conn.fut.close()
		end
		return sz
	end

	public function set_conn(_conn as awaitable_wrapper)
		conn = _conn
	end

	public function __init__(_s as socket_t)
		s = _s
		buf = new byte * 10
	end

	public function recv() as awaitable => s.recv_async(buf,0,10).and_then(this.recv_callback)
end


func accept_callback(sock as option[socket_t]) as option[int]
	println("ACCEPT")
	dim conn_handler = new connection_handler(sock.get())
	dim conn = poll.add(conn_handler.recv())
	conn_handler.set_conn(conn)
	poll.replace(accept_conn, server.accept_async().and_then(accept_callback))
	return some(0)
end
accept_conn.fut = server.accept_async().and_then(accept_callback)

while true
	poll.await(0-1)
end
server.close()