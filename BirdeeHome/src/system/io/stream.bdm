package system.io

import vector:vector
import extensions.string:*

class abstract_input_stream
	private buffer as byte[]
	private pos as uint
	private buf_size as uint
	private read_size as uint
	private strbuf as vector[byte]
	public function __init__(_buf_size as uint)
		buf_size = _buf_size
		buffer = new byte * buf_size
		pos = 0
		read_size = 0
		strbuf = new vector[byte](0)
	end

	public abstract function read_to_buffer(buf as byte[], buf_size as uint) as uint

	private function read()
		read_size = read_to_buffer(buffer, buf_size)#file.read(buffer, 0, buf_size)
		pos = 0
	end

	public function get_char() as byte
		if pos >= read_size then
			read()
			if read_size == 0 then 
				return -1
			end
		end
		dim ret = buffer[pos]
		pos = pos + 1
		return ret
	end

	public function peek() as byte
		if pos >= read_size then
			read()
			if read_size == 0 then 
				return -1
			end
		end
		return buffer[pos]
	end

	private function get_str() as string
		dim ret = new string:copy_bytes(strbuf.buffer(),0,strbuf.size())
		strbuf.clear()
		return ret
	end

	public function get_until(delimiter as byte) as string
		dim cur = get_char()
		while cur!= -1
			strbuf.push_back(cur)
			if cur==delimiter then
				break
			end
			cur = get_char()
		end
		return get_str()
	end

	public func next_token(delimiter as string) as string
		dim c = get_char()
		while c != -1
			if delimiter.find_char(c,0) >= 0 then
					while delimiter.find_char(peek(), 0) >=0
						get_char()
					end
					break
			end
			strbuf.push_back(c)
			c = get_char()
		end
		return get_str()
	end

	public function get_line() as string => get_until({@
from bdutils import *
set_char('\n')
@})

end

class input_stream[T]: abstract_input_stream
	private file as T
	public function __init__(f as T)
		super.__init__(1024)
		file = f
	end

	public function read_to_buffer(buf as byte[], buf_size as uint) as uint
		return file.read(buf, 0, buf_size)
	end
end
