package system.specific.win32

import system.specific.win32.file:CloseHandle
import system.specific.win32.file:GetLastError
import functional.option:*
import concurrent.syncdef:*
import hash:*
import vector:vector

declare function WaitForSingleObject(hHandle as pointer, dwMilliseconds as int) as int
declare function CreateEventA(lpEventAttributes as pointer, bManualReset as boolean, bInitialState as boolean, lpName as pointer) as pointer
declare function SetEvent(hEvent as pointer) as boolean
declare function ResetEvent(hEvent as pointer) as boolean
declare function CreateMutexA(lpMutexAttributes as pointer, bInitialOwner as boolean, lpName as pointer) as pointer
declare function ReleaseMutex(hMutex as pointer) as int
declare function CreateThread(lpThreadAttributes as pointer, dwStackSize as ulong, lpStartAddress as pointer, arg as pointer, dwCreationFlags as int, lpThreadId as pointer) as pointer
declare function ExitThread(status as int)
declare function Sleep(ms as int)
declare function WaitForMultipleObjects(nCount as int,lpHandles as pointer, bWaitAll as boolean, dwMilliseconds as int) as int

@init_script
{@
from bdconst import *
define("WAIT_ABANDONED", 0x00000080)
define("WAIT_OBJECT_0", 0)
define("WAIT_TIMEOUT", 0x00000102)
define("WAIT_FAILED", 0xFFFFFFFF)
@}

struct mutex_t
	private v as pointer
	public function init()
		v = CreateMutexA(pointerof(null), false, pointerof(null))
	end

	public function enter()
		do_wait(v)
	end

	public function leave()
		if ReleaseMutex(v) == 0 then
			throw new wait_exception(GetLastError())
		end
	end

	public function del()
		CloseHandle(v)
	end
end


@private
function do_wait(handle as pointer)
	if WaitForSingleObject(handle, 0-1) != {@WAIT_OBJECT_0()@} then
		throw new wait_exception(GetLastError())
	end
end

class future_impl[T] : concurrent.syncdef.future[T]
	private data as T
	private is_success as boolean
	private native as pointer
	public function __init__()
		is_success = false
		native = CreateEventA(pointerof(null), true, false, pointerof(null))
	end

	public function preset(data as T)
		this.data = data
		is_success = true
	end

	public function success(data as T)
		is_success = true
		this.data = data
		SetEvent(native)
	end

	public function fail()
		is_success = false
		SetEvent(native)
	end

	public function get_native_handle() as pointer => native
	public function do_then() => __del__()
	public function get_result() as option[T]
		if is_success then
			return some(data)
		else
			return none[T]()
		end
	end

	public function do_await() => do_wait(native)
	public function close() => __del__()
	public function __del__()
		if native != pointerof(null) then
			CloseHandle(native)
			native = pointerof(null)
		end
	end
end

function do_create_thread(routine as pointer, arg as pointer) as pointer
	return CreateThread(pointerof(null),0,routine,arg,0,pointerof(null))
end

function do_exit_thread()
	ExitThread(0)
end

function _sleep(ms as int)
	Sleep(ms)
end

function _join_thread(handle as pointer)
	do_wait(handle)
end

function _close_thread(handle as pointer)
	CloseHandle(handle)
end

#waits for events in aw, uses natives as a buffer. size of natives should > len
function _await_multiple_awaitables_with_buffer(aw as awaitable[],offset as uint, len as uint, natives as pointer[], timeout as int) as awaitable
	for dim i =0 till len
		natives[i] = aw[i + offset].get_native_handle()
		if natives[i] == pointerof(null) then
			throw new runtime_exception("_await_multiple_awaitables expects all awaitables having native handlers")
		end
	end
	dim ret = WaitForMultipleObjects(len, natives.get_raw(), false, timeout)
	if ret >= {@WAIT_OBJECT_0()@} && ret < len + {@WAIT_OBJECT_0()@} then
		return aw[ret - {@WAIT_OBJECT_0()@} + offset]
	else if ret == {@WAIT_TIMEOUT()@} then
		return null
	end
	throw new wait_exception(GetLastError())
end

function _await_multiple_awaitables(aw as awaitable[],offset as uint, len as uint, timeout as int) as awaitable
	return _await_multiple_awaitables_with_buffer(aw, offset, len, new pointer * len, timeout)
end

class _poller
	private fut_set as hash_set[awaitable_wrapper]
	private futures as vector[awaitable]
	private handles as pointer[]

	public function __init__()
		fut_set = new hash_set[awaitable_wrapper]
		futures = new vector[awaitable](0)
		handles = null
	end

	private function perpare_handle_buffer()
		if handles === null || handles.length() < futures.size() then
			handles = new pointer * futures.size()
		end
	end

	public function add(ev as awaitable) as awaitable_wrapper
		dim ret = new awaitable_wrapper(ev)
		fut_set.insert(ret)
		return ret
	end

	public function replace(itr as awaitable_wrapper, newev as awaitable)
		itr.fut = newev
	end

	public function remove(itr as awaitable_wrapper)
		fut_set.remove(itr)
	end

	public function await(timeout as uint) as awaitable
		dim itr = fut_set.front()
		while itr!=fut_set.ends()
			futures.push_back(itr.getk().fut)
			itr.forward()
		end
		perpare_handle_buffer()
		dim ret = _await_multiple_awaitables_with_buffer(futures.buffer() ,0,fut_set.size(), handles, 0-1)
		ret.do_then()
		futures.clear()
		return ret
	end
end

##
function await_multiple_awaitables(gen_native as closure (idx as uint) as awaitable, len as uint,timeout as int) as int
	dim natives = new pointer * len
	for dim i=0 till len
		natives[i] = gen_native(i).get_native_handle()
		if natives[i] == pointerof(null) then
			throw new runtime_exception("await_multiple_awaitables expects all awaitables having native handlers")
		end
	end
	return _await_multiple_awaitable_handles(natives, timeout)
end

function _await_multiple_awaitable_handles(natives as pointer[],timeout as int) as int
	dim ret = WaitForMultipleObjects(natives.length(), natives.get_raw(), false, timeout)
	if ret >= {@WAIT_OBJECT_0()@} && ret < len + {@WAIT_OBJECT_0()@} then
		return ret - {@WAIT_OBJECT_0()@}
	else if ret == {@WAIT_TIMEOUT()@} then
		return 0-1
	end
	throw new wait_exception(GetLastError())
end##