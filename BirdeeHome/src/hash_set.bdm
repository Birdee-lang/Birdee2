import hash_map:int_hash
import hash_map:hash
import unsafe:ptr_cast

@enable_rtti
class hash_key_error

end

struct hash_data[K,V]
	public k as K
	public v as V
	public func __hash__() as uint => hash[K](k)
	public func __eq__(other as hash_data[K,V]) as boolean => k == other.k
end

class hash_node[T]
	public next as hash_node[T]
	public data as T
	public hash_cache as uint
end

class hash_node_nodata[T]
	public next as hash_node[T]
end

class hash_set[T]
	private buckets as hash_node[T][]
	private buckets_num as uint
	private lsize as uint
	private allnodes as hash_node[T]
	public function __init__()
		lsize = 0
		buckets_num = 100
		buckets = new hash_node[T] * 100
		for dim i = 0 till buckets_num
			buckets[i] = null
		end
		allnodes = unsafe.ptr_cast[hash_node[T],hash_node_nodata[T]](new hash_node_nodata[T])
		allnodes.next = null
	end

	private function find_node_before(h as uint, t as hash_node[T]) as hash_node[T]
		dim cur = buckets[h % buckets_num]
		while cur.next !== t
			cur = cur.next
		end
		return cur
	end

	private function do_find(h as uint, t as T) as hash_node[T]
		dim cur = buckets[h % buckets_num].next
		while cur !== null
			if cur.data == t then
				return cur
			end
			cur = cur.next
		end
		return null
	end

	private function find(t as T) as hash_node[T] => do_find(hash[T](t), t)

	public function has(t as T) as boolean
		return find(t) !== null
	end

	public function insert(t as T)
		dim h = hash[T](t)
		if do_find(h, t) !== null then
			throw new hash_key_error
		else
			dim lst = buckets[h % buckets_num]
			dim node = new hash_node[T]
			node.data = t
			node.hash_cache = h
			#if is empty bucket, link the node to list head
			#else, simply insert
			if lst === null then
				node.next = allnodes.next
				allnodes.next = node
				buckets[h % buckets_num] = allnodes
			else			
				node.next = lst.next
				lst.next = node
			end
			lsize = lsize + 1
		end
	end

	public function remove(t as T) as boolean
		dim h = hash[T](t)
		dim node = do_find(h, t)
		if node === null then
			throw new hash_key_error
		else
			dim cur_idx = h % buckets_num
			dim lst = buckets[cur_idx]
			dim prev = find_node_before(h, node)
			dim next_idx = 0u
			dim next = node.next
			if next!==null then
				next_idx = next.hash_cache & buckets_num
			end
			if prev === lst then
				#then current node is the first of the bucket
				if next === null || next_idx != cur_idx then
					#after removal, the bucket is empty
					if next!==null then
						buckets[next_idx] = buckets[cur_idx]
					end
					buckets[cur_idx] = null
				end
			else if next!==null then
				#if current node is in the bucket set
				if next_idx != cur_idx then
					buckets[next_idx] = prev
				end
			end
			prev->next=node->next
			#return node->next
			lsize = lsize - 1
			return true
		end
	end

	public function clear()
		for dim i = 0 till buckets_num
			buckets[i] = null
		end
		lsize = 0
	end

	public function size() as uint
		return lsize
	end

	public function empty() as boolean
		return lsize == 0
	end

end