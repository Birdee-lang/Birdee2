import list:list
import list:list_iterator
import list:mk_list_iterator
import hash_map:int_hash
import hash_map:hash
import tuple:tuple

@enable_rtti
class hash_key_error

end

struct hash_data[K,V]
	public k as K
	public v as V
	public __hash__() as uint => hash[K](k)
end

class hash_set[T]
	private buckets as list[T][]
	private buckets_num as int
	private lsize as uint
	public function __init__()
		lsize = 0
		buckets_num = 100
		buckets = new list[T] * 100
		for dim i = 0 till buckets_num
			buckets[i] = new list[T]
		end
	end

	private function do_find(h as uint, t as T) as list_iterator[T]
		dim lst = buckets[h % buckets_num]
		dim cur = lst.front()
		while cur != lst.end()
			if cur.get() == t then
				return cur
			end
			cur.forward()
		end
		return mk_list_iterator[T](null)
	end

	private function find(t as T) as list_iterator[T] => do_find(hash[T](t), t)

	public function has(t as T) as boolean
		return find(t)._node !== null
	end

	public function insert(t as T)
		if find(t)._node !== null then
			throw new hash_key_error
		else
			dim h = hash[T](t)
			dim lst = buckets[h % buckets_num]
			lsize = lsize + 1
			lst.insert_back(t)
		end
	end

	public function remove(t as T) as boolean
		dim h = hash[T](t)
		dim node = do_find(h, t)
		if node._node === null then
			return false
		else
			dim lst = buckets[h % buckets_num]
			lsize = lsize - 1
			lst.remove(node._node)
			return true
		end
	end

	public function clear()
		for dim i = 0 till buckets_num
			buckets[i].clear()
		end
		lsize = 0
	end

	public function size() as uint
		return lsize
	end

	public function empty() as boolean
		return lsize == 0
	end

end