package concurrent

import unsafe

struct closure_unpacked
	public funcptr as pointer
	public data as pointer
end

@init_script
{@
from traits import *
from traits import _
from bdutils import *

osname =  get_os_name()
def check_arg_is_functype(idx):
	def checker(fn):
		ty = get_function_arg_at(fn,0).resolved_type
		require_(is_prototype(ty))
	return checker

def check_arg_is_closure(idx):
	def checker(fn):
		ty = get_function_arg_at(fn,0).resolved_type
		require_(is_prototype(ty))
		require_( (ty.get_detail().is_closure, lambda:"Expecting a closure"))
	return checker

def expand_vararg(func, idx_start):
	args = func.proto.args
	ret = ""
	for i in range(idx_start,len(args)):
		ret+= args[i].name+','
	return ret[:-1]
@}

@check_arg_is_closure(0)
function unpack_closure[T](f as T) as closure_unpacked => unsafe.ptr_load[closure_unpacked](addressof(f))

{@
os_function_decl = {
	'windows':{
		'create':'declare function CreateThread(lpThreadAttributes as pointer, dwStackSize as ulong, lpStartAddress as pointer, arg as pointer, dwCreationFlags as int, lpThreadId as pointer) as pointer',
		'exit': 'declare function ExitThread(status as int)',
		'sleep': 'declare function Sleep(ms as int)'
	},
	'linux':{
		'create':'declare function pthread_create(ptr_thread_id as pointer, attr as pointer, routine as pointer, arg as pointer) as int',
		'exit': 'declare function pthread_exit(p as pointer)',
		'sleep': 'declare function Sleep alias "sleep" (seconds as int) '
	}
}
set_ast(stmt(os_function_decl[osname]['create']))
@}
{@set_ast(stmt(os_function_decl[osname]['exit']))@}
{@set_ast(stmt(os_function_decl[osname]['sleep']))@}

function sleep(ms as int)
	ms = ms / {@
if osname=='windows':
	set_int(1)
else:
	set_int(1000)
@}
	Sleep(ms)
end

function do_create_thread(routine as pointer, arg as pointer) as pointer
	dim ret as pointer
{@
if osname=='windows':
	set_ast(expr("ret=CreateThread(pointerof(null),0,routine,arg,0,pointerof(null))"))
elif osname=='linux':
	set_ast(expr("pthread_create(addressof(ret),pointerof(null),routine,arg)"))
else:
	assert(False)
@}
	return ret
end

function do_exit_thread()
{@
if osname=='windows':
	set_expr("ExitThread(0)")
elif osname=='linux':
	set_expr("pthread_exit(pointerof(null))")
else:
	assert(False)
@}
end

class thread
	private handle as pointer

	public function __init__[T,...](fn as T, ...)
{@
func=get_cur_func()
check_arg_is_functype(0)(func)
@}
		dim f = function ()
			{@set_ast(expr("fn({})".format(expand_vararg(func,1))))@}
			{@if osname=='linux': set_ast(expr("do_exit_thread()"))@}		
		end
		dim unpacked = unpack_closure(f)
		handle = do_create_thread(unpacked.funcptr,unpacked.data)
	end
end


##func aaaa()
	dim a as int
	dim b = func()
		a
		println("hi")
	end
	dim clo = unpack_closure(b)
	println(pointer2str(clo.data))
	println(pointer2str(clo.funcptr))
end

aaaa()##



